#!/usr/bin/env ruby

require 'pathname'
require 'optparse'
require 'pp'

Options = Struct.new(:source, :binary, :symbols, :ranges, :standalone)

class Parser
  def self.parse(options)
    args = Options.new()

    opt_parser = OptionParser.new do |opts|
      opts.banner = "Usage: -s <source> -b <binary> -s <symbols> [-r=<type>:<start>:<end>[,[...]]] [-S]"

      opts.on("-sSOURCE", "--source=SOURCE", "Acme source file") do |source|
        args.source = source
      end

      opts.on("-bBINARY", "--binary=BINARY", "Binary assembled from acme source file") do |binary|
        args.binary = binary
      end

      opts.on("-ySYMBOLS", "--symbols=SYMBOLS", "Symbol file generated by acme") do |symbols|
        args.symbols = symbols
      end

      opts.on("-rranges", "--ranges=ranges", "Ranges for da65 info file") do |ranges|
        args.ranges = ranges
      end

      opts.on("-S", "--standalone", "Add processor type and origin for test assembly") do |standalone|
        args.standalone = standalone
      end

      opts.on("-h", "--help", "Prints this help") do
        puts opts
        exit
      end
    end

    opt_parser.parse!(options)
    return args
  end
end

AssemblerSymbol = Struct.new(:name, :value, :unused);

class AssemblyRange
    def initialize(type, start, stop)
        @type = type
        @start = start
        @stop = stop
    end

    def self.parse(spec)
        (type, start, stop) = spec.split(':')
        return AssemblyRange.new(type, start, stop)
    end

    def resolve(symbols)
        @start = symbols.by_name(@start).value.to_s(16).rjust(4, '0')
        @stop = (symbols.by_name(@stop).value - 3).to_s(16).rjust(4, '0')
    end

    def to_s
        "RANGE { START $#{@start}; END $#{@stop}; TYPE #{@type.upcase}; };"
    end
end

class Array
    def by_name(name)
        self.each do |object|
            return object if object[:name] == name
        end
        nil
    end

    def by_value(value)
        self.each do |object|
            return object if object[:value] == value
        end
        nil
    end
end

class Export
    def initialize(options)
        @acme_source_path = Pathname.new(options.source)
        @binary_path = Pathname.new(options.binary)
        @symbolfile_path = Pathname.new(options.symbols)
        @standalone = options.standalone
        @dasm_source_path = Pathname.new(@acme_source_path.to_s.sub /\.asm/, '.dasm')

        @labels = []
        @definitions = []

        @ranges = []
        parse_ranges(options.ranges)
    end

    def export
        @acme_source_path.each_line do |line|
            if line =~ /^\s*([\w\d_]+)\s*([:=]).*?;\s*EXPORT/
                name = $1
                type = $2
                if type == ':'
                    @labels << AssemblerSymbol.new(name)
                elsif type == '='
                    @definitions << AssemblerSymbol.new(name)
                end
            end
        end

        @symbolfile_path.each_line do |line|
            if line =~ /([\w\d_]+)\s*=\s*\$([0-9a-fA-F]+).*?(unused)?/
                name = $1
                value = $2
                unused = !$3.nil?

                if (label = @labels.by_name(name))
                    label.value = value.to_i(16)
                    label.unused = unused
                end

                if (definition = @definitions.by_name(name))
                    definition.value = value.to_i(16)
                    definition.unused = unused
                end
            end
        end

        (@labels + @definitions).each do |symbol|
            if symbol.value.nil?
                STDERR.puts("Could not resolve exported label #{symbol.name}")
            end
        end

        da65_options = '--cpu 6502 -S\$1000 --label-break 4 --comments 1'

        unless @ranges.empty?
            da65_info_file = "/tmp/#{@acme_source_path}.info"
            File.open(da65_info_file, 'w') do |file|
                @ranges.each do |range|
                    range.resolve(@labels)
                    file.puts(range)
                end
            end
            da65_options += " -i #{da65_info_file}"
        end

        dasm_pass_0 = `da65 #{da65_options} #{@binary_path}`
        dasm_pass_1 = ''
        dasm_pass_2 = ''

        STDERR.puts "\nExported Symbols:\n\n"
        (@labels + @definitions).each do |label|
            STDERR.puts("\t%s" % label.name)
        end
        STDERR.puts("\n")

        dasm_pass_0.each_line do |line|
            while line =~ /L([0-9a-fA-F]{4})/
                da65_label = $&
                address = $1.to_i(16)

                symbol = @definitions.reverse.by_value(address)
                if symbol && line !~ /^#{da65_label}/
                    line.gsub! da65_label, symbol.name
                    next
                end

                symbol = @labels.reverse.by_value(address)
                if symbol
                    line.gsub! da65_label, symbol.name
                    next
                end
                break
            end
            dasm_pass_1 += line
        end

        dasm_pass_1.each_line do |line|
            while line =~ /L([0-9a-fA-F]{4})/
                da65_label = $&
                address = $1.to_i(16)
                line.gsub! da65_label, "_wic64_#{address.to_s(16).rjust(4, '0')}"
            end

            line.gsub! ':=', 'equ'

            if line !~ /\.setcpu/
                dasm_pass_2 += line
            end
        end

        if @standalone
            puts "\tprocessor 6502"
            puts "\torg $1000"
        end

        @definitions.each do |definition|
            puts "%s equ %s" % [definition.name, definition.value]
        end

        puts dasm_pass_2
    end

    def parse_ranges(specs)
        return unless specs

        specs.split(',').each do |spec|
            range = AssemblyRange.parse(spec)
            @ranges << range
        end
    end
end

options = Parser.parse(ARGV.empty? ? %w[--help] : ARGV)

Export.new(options).export()